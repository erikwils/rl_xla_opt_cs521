HloModule test_algebraic_simplifier_14, entry_computation_layout={()->(f32[4,4]{1,0}, f32[4,4]{1,0}, f32[4,4]{1,0}, f32[4,4]{1,0}, f32[4,4]{1,0})}

ENTRY %main () -> (f32[4,4], f32[4,4], f32[4,4], f32[4,4], f32[4,4]) {
  %constant_half = f32[] constant(0.5)
  %half_array = f32[4,4]{1,0} broadcast(%constant_half), dimensions={}
  %constant_e = f32[] constant(2.71828)
  %e_array = f32[4,4]{1,0} broadcast(%constant_e), dimensions={}
  %constant_pi = f32[] constant(3.14159)
  %pi_array = f32[4,4]{1,0} broadcast(%constant_pi), dimensions={}
  %constant_zero = f32[] constant(0)
  %zero_array = f32[4,4]{1,0} broadcast(%constant_zero), dimensions={}
  %mul_zero_14_0 = f32[4,4]{1,0} multiply(%pi_array, %zero_array)
  %constant_neg_one = f32[] constant(-1)
  %neg_one_array = f32[4,4]{1,0} broadcast(%constant_neg_one), dimensions={}
  %constant_one = f32[] constant(1)
  %one_array = f32[4,4]{1,0} broadcast(%constant_one), dimensions={}
  %multiply.anon = f32[4,4]{1,0} multiply(%neg_one_array, %one_array)
  %complex_pow_mul_14_1 = f32[4,4]{1,0} power(%multiply.anon, %one_array)
  %power_zero_14_2 = f32[4,4]{1,0} power(%neg_one_array, %zero_array)
  %constant_two = f32[] constant(2)
  %two_array = f32[4,4]{1,0} broadcast(%constant_two), dimensions={}
  %mul_two_14_3 = f32[4,4]{1,0} multiply(%zero_array, %two_array)
  %complex_combo_14_combo_0 = f32[4,4]{1,0} multiply(%power_zero_14_2, %mul_two_14_3)
  ROOT %result = (f32[4,4]{1,0}, f32[4,4]{1,0}, f32[4,4]{1,0}, f32[4,4]{1,0}, f32[4,4]{1,0}) tuple(%mul_zero_14_0, %complex_pow_mul_14_1, %power_zero_14_2, %mul_two_14_3, %complex_combo_14_combo_0)
}



