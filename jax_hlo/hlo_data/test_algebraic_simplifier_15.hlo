HloModule test_algebraic_simplifier_15, entry_computation_layout={()->(f32[2,3,4]{2,1,0}, f32[2,3,4]{2,1,0}, f32[2,3,4]{2,1,0}, f32[2,3,4]{2,1,0}, f32[2,3,4]{2,1,0}, /*index=5*/f32[2,3,4]{2,1,0}, f32[2,3,4]{2,1,0})}

ENTRY %main () -> (f32[2,3,4], f32[2,3,4], f32[2,3,4], f32[2,3,4], f32[2,3,4], /*index=5*/f32[2,3,4], f32[2,3,4]) {
  %constant_one = f32[] constant(1)
  %one_array = f32[2,3,4]{2,1,0} broadcast(%constant_one), dimensions={}
  %multiply.anon = f32[2,3,4]{2,1,0} multiply(%one_array, %one_array)
  %constant_zero = f32[] constant(0)
  %zero_array = f32[2,3,4]{2,1,0} broadcast(%constant_zero), dimensions={}
  %complex_add_mul_15_0 = f32[2,3,4]{2,1,0} add(%multiply.anon, %zero_array)
  %constant_half = f32[] constant(0.5)
  %half_array = f32[2,3,4]{2,1,0} broadcast(%constant_half), dimensions={}
  %power_one_15_1 = f32[2,3,4]{2,1,0} power(%half_array, %one_array)
  %mul_one_15_2 = f32[2,3,4]{2,1,0} multiply(%zero_array, %one_array)
  %sqrt.anon = f32[2,3,4]{2,1,0} sqrt(%half_array)
  %constant_two = f32[] constant(2)
  %two_array = f32[2,3,4]{2,1,0} broadcast(%constant_two), dimensions={}
  %square_sqrt_15_3 = f32[2,3,4]{2,1,0} power(%sqrt.anon, %two_array)
  %multiply.anon.1 = f32[2,3,4]{2,1,0} multiply(%zero_array, %one_array)
  %complex_pow_mul_15_4 = f32[2,3,4]{2,1,0} power(%multiply.anon.1, %one_array)
  %complex_combo_15_combo_0 = f32[2,3,4]{2,1,0} multiply(%mul_one_15_2, %complex_add_mul_15_0)
  %complex_combo_15_combo_1 = f32[2,3,4]{2,1,0} multiply(%mul_one_15_2, %power_one_15_1)
  ROOT %result = (f32[2,3,4]{2,1,0}, f32[2,3,4]{2,1,0}, f32[2,3,4]{2,1,0}, f32[2,3,4]{2,1,0}, f32[2,3,4]{2,1,0}, /*index=5*/f32[2,3,4]{2,1,0}, f32[2,3,4]{2,1,0}) tuple(%complex_add_mul_15_0, %power_one_15_1, %mul_one_15_2, %square_sqrt_15_3, %complex_pow_mul_15_4, /*index=5*/%complex_combo_15_combo_0, %complex_combo_15_combo_1)
}



