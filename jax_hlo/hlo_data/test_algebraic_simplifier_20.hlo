HloModule test_algebraic_simplifier_20, entry_computation_layout={()->(f32[3,5]{1,0}, f32[3,5]{1,0}, f32[3,5]{1,0}, f32[3,5]{1,0}, f32[3,5]{1,0}, /*index=5*/f32[3,5]{1,0}, f32[3,5]{1,0}, f32[3,5]{1,0})}

ENTRY %main () -> (f32[3,5], f32[3,5], f32[3,5], f32[3,5], f32[3,5], /*index=5*/f32[3,5], f32[3,5], f32[3,5]) {
  %constant_two = f32[] constant(2)
  %two_array = f32[3,5]{1,0} broadcast(%constant_two), dimensions={}
  %constant_half = f32[] constant(0.5)
  %half_array = f32[3,5]{1,0} broadcast(%constant_half), dimensions={}
  %constant_zero = f32[] constant(0)
  %zero_array = f32[3,5]{1,0} broadcast(%constant_zero), dimensions={}
  %mul_zero_20_0 = f32[3,5]{1,0} multiply(%half_array, %zero_array)
  %constant_e = f32[] constant(2.71828)
  %e_array = f32[3,5]{1,0} broadcast(%constant_e), dimensions={}
  %power_zero_20_1 = f32[3,5]{1,0} power(%e_array, %zero_array)
  %constant_one = f32[] constant(1)
  %one_array = f32[3,5]{1,0} broadcast(%constant_one), dimensions={}
  %multiply.anon = f32[3,5]{1,0} multiply(%zero_array, %one_array)
  %complex_add_mul_20_2 = f32[3,5]{1,0} add(%multiply.anon, %zero_array)
  %div_one_20_3 = f32[3,5]{1,0} divide(%zero_array, %one_array)
  %add.anon = f32[3,5]{1,0} add(%half_array, %zero_array)
  %complex_mul_add_20_4 = f32[3,5]{1,0} multiply(%add.anon, %one_array)
  %add.anon.1 = f32[3,5]{1,0} add(%one_array, %one_array)
  %complex_sub_add_20_5 = f32[3,5]{1,0} subtract(%add.anon.1, %one_array)
  %mul_one_20_6 = f32[3,5]{1,0} multiply(%half_array, %one_array)
  %sub_self_20_7 = f32[3,5]{1,0} subtract(%half_array, %half_array)
  ROOT %result = (f32[3,5]{1,0}, f32[3,5]{1,0}, f32[3,5]{1,0}, f32[3,5]{1,0}, f32[3,5]{1,0}, /*index=5*/f32[3,5]{1,0}, f32[3,5]{1,0}, f32[3,5]{1,0}) tuple(%mul_zero_20_0, %power_zero_20_1, %complex_add_mul_20_2, %div_one_20_3, %complex_mul_add_20_4, /*index=5*/%complex_sub_add_20_5, %mul_one_20_6, %sub_self_20_7)
}



