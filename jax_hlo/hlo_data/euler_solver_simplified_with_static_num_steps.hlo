module @jit_euler_solver_for_hlo attributes {mhlo.num_partitions = 1 : i32, mhlo.num_replicas = 1 : i32} {
  func.func public @main(%arg0: tensor<f32> {mhlo.layout_mode = "default"}, %arg1: tensor<f32> {mhlo.layout_mode = "default"}, %arg2: tensor<f32> {mhlo.layout_mode = "default"}) -> (tensor<f32> {jax.result_info = "", mhlo.layout_mode = "default"}) {
    %c = stablehlo.constant dense<0> : tensor<i32>
    %0:4 = stablehlo.while(%iterArg = %arg1, %iterArg_0 = %arg2, %iterArg_1 = %c, %iterArg_2 = %arg0) : tensor<f32>, tensor<f32>, tensor<i32>, tensor<f32>
     cond {
      %c_3 = stablehlo.constant dense<10> : tensor<i32>
      %1 = stablehlo.compare  LT, %iterArg_1, %c_3,  SIGNED : (tensor<i32>, tensor<i32>) -> tensor<i1>
      stablehlo.return %1 : tensor<i1>
    } do {
      %1 = func.call @None(%iterArg, %iterArg_0, %iterArg_2) : (tensor<f32>, tensor<f32>, tensor<f32>) -> tensor<f32>
      %c_3 = stablehlo.constant dense<1> : tensor<i32>
      %2 = stablehlo.add %iterArg_1, %c_3 : tensor<i32>
      stablehlo.return %iterArg, %iterArg_0, %2, %1 : tensor<f32>, tensor<f32>, tensor<i32>, tensor<f32>
    }
    return %0#3 : tensor<f32>
  }
  func.func private @None(%arg0: tensor<f32>, %arg1: tensor<f32>, %arg2: tensor<f32>) -> tensor<f32> {
    %0 = stablehlo.negate %arg0 : tensor<f32>
    %1 = stablehlo.multiply %0, %arg2 : tensor<f32>
    %2 = stablehlo.multiply %arg1, %1 : tensor<f32>
    %3 = stablehlo.add %arg2, %2 : tensor<f32>
    return %3 : tensor<f32>
  }
}
